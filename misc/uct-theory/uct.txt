 const
   UCTK = 1;
 // Larger values give uniform search
 // Smaller values give very selective search

 type
  TMove = (...);
  PNode = ^Node;
  Node = record
    Wins: integer;
    Visits: integer;
    Move: TMove;
    BestNode: PNode;
    Child: PNode;
    Sibling: PNode;
  end;

 function UCTSelect(n: Node): Node;
 begin
  bestuct := 0;
  result := nil;
  next := n.Child;
  while next <> nil do
  begin
    if next.Visits > 0 then
    begin
      winrate := next.Wins/next.Visits;
      uct := UCTK*Sqrt(ln(n.Visits)/(5*next.Visits));
      uctvalue := winrate + uct;
    end
    else
      // Always play a random unexplored move first
      uctvalue := 10000 + random(1000);

    if uctvalue > bestuct then
    begin
      bestuct := uctvalue;
      result := next;
    end;

    next := next.Sibling;
  end;

 end;

 procedure PlaySimulation(n: Node);
 begin
   if n.Visits = 0 then
     randomresult := clone.PlayRandomGame
   else
   begin
     if n.Child = nil then
       CreateChildren(n);

     next := UCTSelect(n);

     clone.MakeMove(next.Move);
     PlaySimulation(next);
   end;

   Inc(n.Visits);
   UpdateWin(n, randomresult);

   if n.Child <> nil then
     SetBest(n);
 end;

 function UCTSearch: TMove;
 begin
  root := GetNode;
  nsimulations := 0;
  while (nsimulations < MaxSimulations ) do
  begin
    clone.CopyState(position);
    PlaySimulation(root);
    Inc(nsimulations);
  end;

  result := root.BestMove;
 end;


